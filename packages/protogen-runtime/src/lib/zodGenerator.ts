import { asArray, getObjKeyCount, HashMap } from "@iyio/common";
import { ProtoAttribute, ProtoContext, ProtoNode } from "@iyio/protogen";

const typeMap:HashMap<string>={
    'int':'number',
    '':'null'
};
const numTypes=['number','bigint'];
const builtIns=['string','number','any','bigint','boolean','date','null'] as const;

export interface ZodGeneratorOptions
{
    /**
     * @arg --zod-def-prefix
     */
    defPrefix?:string;
    /**
     * @arg --zod-def-suffix
     */
    defSuffix?:string;
}

export const zodGenerator=async ({
    nodes,
    outputs,
    args,
    tab,
}:ProtoContext)=>{

    const options:Required<ZodGeneratorOptions>={
        defPrefix:args['--zod-def-prefix']?.[0]??'',
        defSuffix:args['--zod-def-suffix']?.[0]??'Scheme',
    }
    const {
        defPrefix,
        defSuffix
    }=options;

    const getFullName=(name:string)=>`${defPrefix}${name}${defSuffix}`;

    const out:string[]=[];

    const useCustomTypes:CustomBuiltInsType[]=[];

    out.push(`// this file was autogenerated by @iyio/protogen - https://github.com/iyioio/common/packages/protogen`);
    out.push(`// generator = zodGenerator`);
    out.push(`import { z } from 'zod';`);

    for(const node of nodes){

        switch(node.refType?.type){

            case 'union':
                addUnion(node,out,tab,getFullName);
                break;

            case 'enum':
                addEnum(node,out,tab,getFullName);
                break;

            case 'entity':
            case 'struct':
            case 'interface':
            case 'class':
            case 'type':
                addInterface(node,out,tab,getFullName,useCustomTypes);
                break;
        }


    }

    outputs.push({
        ext:'ts',
        content:out.join('\n'),
    })
}

const addEnum=(node:ProtoNode,out:string[],tab:string,getFullName:(name:string)=>string)=>{

    const fullName=getFullName(node.name);

    const children=node.children??[];

    out.push('');
    out.push(`export enum ${node.name}{`);

    for(const child of children){
        out.push(`${tab}${child.name}${child.type?'='+child.type:''},`)
    }

    out.push('}')

    out.push(`export const ${fullName}=z.nativeEnum(${node.name})`);
}

const addUnion=(node:ProtoNode,out:string[],tab:string,getFullName:(name:string)=>string)=>{

    const fullName=getFullName(node.name);


    out.push('');
    out.push(`export const ${fullName}=z.enum([`);

    const children=node.children??[];
    for(const child of children){
        out.push(`${tab}${JSON.stringify(child.name)},`)
    }

    out.push(`]);`);
    out.push(`export type ${node.name}=z.infer<typeof ${fullName}>;`);
}

const addInterface=(node:ProtoNode,out:string[],tab:string,getFullName:(name:string)=>string,useCustomTypes:CustomBuiltInsType[])=>{
    const fullName=getFullName(node.name);

    const hasCustoms=node.children?.some(c=>!isBuiltInType(c.type))?true:false;

    out.push('');
    if(hasCustoms){
        out.push(`const __base__${fullName}=z.object({`);
    }else{
        out.push(`export const ${fullName}=z.object({`);
    }
    const interfaceProps:string[]=[];
    const lazyProps:string[]=[];

    if(node.children){
        for(const prop of node.children){

            const propType=typeMap[prop.type]??prop.type??'string';
            const isBuiltIn=isBuiltInType(propType);

            if(!isBuiltIn){
                interfaceProps.push(`${
                        prop.comment?formatComment(prop.comment,tab)+'\n':''
                    }${
                        tab
                    }${
                        prop.name
                    }${
                        prop.optional?'?':''
                    }:${
                        propType
                    };`
                );
                lazyProps.push(`${
                        tab
                    }${
                        prop.name
                    }:z.lazy(()=>${
                        getFullName(propType)
                    })${getFormatCalls(prop,propType)}${
                        prop.optional?'.optional()':''
                    },`
                );
                continue;
            }

            const customType=getRealCustomType(propType as any);
            if(customType && !useCustomTypes.includes(propType as any)){
                useCustomTypes.push(propType as any)
            }

            out.push(`${
                    prop.comment?formatComment(prop.comment,tab)+'\n':''
                }${
                    tab
                }${
                    prop.name
                }:${
                    customType||`z.${propType}()${getFormatCalls(prop,propType)}`
                }${
                    prop.isArray?'.array()':''
                }${
                    prop.optional?'.optional()':''
                },`
            );
        }
    }

    out.push('});');
    if(hasCustoms){
        out.push(`export const ${fullName}=z.object({`);
        for(const prop of lazyProps){
            out.push(prop);
        }
        out.push('});')
    }
    if(node.comment){
        out.push(formatComment(node.comment,''));
    }
    if(interfaceProps.length){
        out.push(`export type ${node.name}=z.infer<typeof ${hasCustoms?'__base__':''}${fullName}> & {`);

        for(const prop of interfaceProps){
            out.push(prop);
        }

        out.push('};')
    }else{
        out.push(`export type ${node.name}=z.infer<typeof ${hasCustoms?'__base__':''}${fullName}>;`);
    }
}

const customBuiltIns=['StringMap','NumberMap','BooleanMap','DateMap','BigIntMap'] as const;
type CustomBuiltInsType=typeof customBuiltIns[number];
const getRealCustomType=(type:CustomBuiltInsType)=>{
    switch(type){
        case 'StringMap': return 'z.record(z.string())';
        case 'NumberMap': return 'z.record(z.number())';
        case 'BooleanMap': return 'z.record(z.boolean())';
        case 'DateMap': return 'z.record(z.date())';
        case 'BigIntMap': return 'z.record(z.bigint())';
        default: return null;
    }
}
const isBuiltInType=(type:string)=>{
    return builtIns.includes(type as any) || customBuiltIns.includes(type as any);
}

const formatComment=(comment:string,tab:string)=>(
    `${tab}/**\n${tab} * ${comment.split('\n').join(`\n${tab} * `)}\n${tab} */`
)

interface AddCallOptions
{
    defaultValue?:string;
    hasMessage?:boolean;
    rawValue?:boolean;
    option?:(att:ProtoAttribute)=>string|null;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const getFormatCalls=(prop:ProtoNode,propType:string):string=>{
    let call='';

    const add=(type:string|string[],name:string,att:ProtoAttribute|undefined,getValue?:((att:ProtoAttribute)=>string|number|null|undefined)|null,{
        defaultValue,
        hasMessage=true,
        rawValue,
        option
    }:AddCallOptions={})=>{
        if(!att){
            return;
        }
        type=asArray(type);
        if(!type.includes(propType)){
            return;
        }
        let value=getValue?.(att)??defaultValue;
        if(typeof value === 'string'){
            value=value.trim()
        }
        if(!rawValue && (typeof value ==='string')){
            value=JSON.stringify(value)
        }
        const message=option?option(att):att.props['message']?.trim();
        call+=`.${name}(${value??''}${(message && hasMessage)?(value?',':'')+(option?message:JSON.stringify(message)):''})`

    }

    let noAutoLength=prop.attributes['email']?true:false;

    if(propType==='string' && !prop.attributes['email'] && /(^e|E)mail($|[A-Z\d_])/.test(prop.name)){
        call+='.email()';
        noAutoLength=true;
    }

    if( !noAutoLength &&
        propType==='string' &&
        !prop.attributes['max'] &&
        !parseBool(prop.attributes['long']?.value,false)
    ){
        call+='.max(255)';
    }

    if(propType==='number' && !prop.attributes['int']){
        call+='.int()';
    }

    add(['string',...numTypes],'min',prop.attributes['min'],att=>parseNum(att.value))
    add(['string',...numTypes],'max',prop.attributes['max'],att=>parseNum(att.value))
    add(['string'],'length',prop.attributes['length'],att=>parseNum(att.value))
    add(['string'],'endsWith',prop.attributes['endsWith'],att=>att.value)
    add(['string'],'startsWith',prop.attributes['startsWith'],att=>att.value)
    add(['string'],'email',prop.attributes['email']);
    add(['string'],'url',prop.attributes['url']);
    add(['string'],'emoji',prop.attributes['emoji']);
    add(['string'],'uuid',prop.attributes['uuid']);
    add(['string'],'cuid',prop.attributes['cuid']);
    add(['string'],'cuid2',prop.attributes['cuid2']);
    add(['string'],'ulid',prop.attributes['ulid']);
    add(['string'],'nonempty',prop.attributes['notEmpty']);
    add(['string'],'trim',prop.attributes['trim'],null,{hasMessage:false});
    add(['string'],'toLowerCase',prop.attributes['lower'],null,{hasMessage:false});
    add(['string'],'toUpperCase',prop.attributes['upper'],null,{hasMessage:false});

    add('string','ip',prop.attributes['ip'],att=>parseObj({
        version:att.value||'v4',
        message:att.props['message'],
    }),{hasMessage:false,rawValue:true})

    add('string','datetime',prop.attributes['date'],att=>parseObj({
        precision:parseNum(att.value),
        offset:Boolean(att.value),
        message:att.props['message'],
    }),{hasMessage:false,rawValue:true})

    add('string','regex',prop.attributes['regex'],att=>paseRegex(att),{rawValue:true})

    add('string','includes',prop.attributes['includes'],att=>att.value,{
        option:att=>parseObj({
            position:parseNum(att.value),
            message:att.props['message'],
        })
    })


    add(numTypes,'gte',prop.attributes['gte'],att=>parseNum(att.value))
    add(numTypes,'gt',prop.attributes['gt'],att=>parseNum(att.value))
    add(numTypes,'lte',prop.attributes['lte'],att=>parseNum(att.value))
    add(numTypes,'lt',prop.attributes['lt'],att=>parseNum(att.value))
    add(numTypes,'multipleOf',prop.attributes['multipleOf'],att=>parseNum(att.value))
    add(numTypes,'step',prop.attributes['step'],att=>parseNum(att.value))
    add(numTypes,'int',prop.attributes['int'])
    add(numTypes,'positive',prop.attributes['positive'])
    add(numTypes,'negative',prop.attributes['negative'])
    add(numTypes,'nonpositive',prop.attributes['notPositive'])
    add(numTypes,'nonnegative',prop.attributes['notNegative'])
    add(numTypes,'finite',prop.attributes['finite'])
    add(numTypes,'safe',prop.attributes['safe'])

    add('date','min',prop.attributes['min'],att=>`new Date(${JSON.stringify(att.value)})`,{rawValue:true})
    add('date','max',prop.attributes['max'],att=>`new Date(${JSON.stringify(att.value)})`,{rawValue:true})

    return call;

}


const parseNum=(str:string|null|undefined)=>{
    if(!str){
        return undefined;
    }
    const n=Number(str);
    return isFinite(n)?n:undefined;
}

const parseObj=(obj:any)=>{
    for(const e in obj){
        const value=typeof obj[e]==='string'?obj[e].trim():obj[e];
        if(value===''){
            delete obj[e];
        }else{
            obj[e]=value;
        }
    }
    return getObjKeyCount(obj)?JSON.stringify(obj):null;
}

const paseRegex=(att:ProtoAttribute)=>{
    if(!att.value){
        return null;
    }
    try{
        new RegExp(att.value);
        const flags=att.props['flags']??'';
        return `/${att.value}/${
            flags.includes('i')?'i':''
        }${
            flags.includes('g')?'g':''
        }${
            flags.includes('m')?'m':''
        }${
            flags.includes('s')?'s':''
        }${
            flags.includes('u')?'u':''
        }${
            flags.includes('y')?'y':''
        }`;
    }catch{
        return null;
    }
}

const parseBool=(value:string|undefined,defaultValue:boolean):boolean=>{
    if(!value){
        return defaultValue;
    }
    value=value.trim();
    if(!value){
        return defaultValue;
    }
    return Boolean(value);
}
